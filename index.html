<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Gesture Controlled 3D Particle Universe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: black;
    }
    video {
      display: none;
    }
  </style>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>
</head>

<body>
<video id="video" autoplay playsinline></video>

<script>
/* -------------------- THREE SETUP -------------------- */

const scene = new THREE.Scene()
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000)
camera.position.z = 120

const renderer = new THREE.WebGLRenderer({ antialias: true })
renderer.setSize(window.innerWidth, window.innerHeight)
document.body.appendChild(renderer.domElement)

/* -------------------- PARTICLE SYSTEM -------------------- */

const PARTICLE_COUNT = 12000
let geometry = new THREE.BufferGeometry()
let positions = new Float32Array(PARTICLE_COUNT * 3)
let colors = new Float32Array(PARTICLE_COUNT * 3)

const material = new THREE.PointsMaterial({
  size: 1.5,
  vertexColors: true
})

const particles = new THREE.Points(geometry, material)
scene.add(particles)

/* -------------------- SHAPE GENERATORS -------------------- */

const Shapes = [
  // Sphere
  (i) => {
    const phi = Math.acos(1 - 2 * Math.random())
    const theta = Math.random() * Math.PI * 2
    return [
      Math.sin(phi) * Math.cos(theta),
      Math.cos(phi),
      Math.sin(phi) * Math.sin(theta)
    ]
  },

  // Heart
  (i) => {
    const t = Math.random() * Math.PI * 2
    const x = 16 * Math.pow(Math.sin(t), 3)
    const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)
    return [x / 10, y / 10, (Math.random() - 0.5)]
  },

  // Star
  (i) => {
    const r = Math.random() * 20
    const a = Math.random() * Math.PI * 2
    return [Math.cos(a) * r, Math.sin(a) * r, (Math.random() - 0.5) * 20]
  },

  // Saturn Rings
  (i) => {
    const angle = Math.random() * Math.PI * 2
    const radius = 20 + Math.random() * 10
    return [Math.cos(angle) * radius, (Math.random() - 0.5) * 3, Math.sin(angle) * radius]
  },

  // Firework
  (i) => {
    const v = new THREE.Vector3(
      Math.random() - 0.5,
      Math.random() - 0.5,
      Math.random() - 0.5
    ).normalize().multiplyScalar(Math.random() * 30)
    return [v.x, v.y, v.z]
  }
]

let currentShape = 0

function generateShape(scale = 20) {
  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const p = Shapes[currentShape](i)
    positions[i * 3] = p[0] * scale
    positions[i * 3 + 1] = p[1] * scale
    positions[i * 3 + 2] = p[2] * scale

    colors[i * 3] = Math.random()
    colors[i * 3 + 1] = Math.random()
    colors[i * 3 + 2] = Math.random()
  }

  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3))
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3))
}

generateShape()

/* -------------------- HAND TRACKING -------------------- */

let handX = 0
let handY = 0
let handDistance = 0
let pinch = false

const hands = new Hands({
  locateFile: (file) =>
    `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
})

hands.setOptions({
  maxNumHands: 1,
  modelComplexity: 1,
  minDetectionConfidence: 0.7,
  minTrackingConfidence: 0.7
})

hands.onResults((results) => {
  if (!results.multiHandLandmarks.length) return

  const lm = results.multiHandLandmarks[0]
  const thumb = lm[4]
  const index = lm[8]

  handX = (index.x - 0.5) * 2
  handY = (0.5 - index.y) * 2
  handDistance = Math.abs(index.z)

  const dx = thumb.x - index.x
  const dy = thumb.y - index.y
  pinch = Math.sqrt(dx * dx + dy * dy) < 0.05
})

const video = document.getElementById('video')
const cam = new Camera(video, {
  onFrame: async () => await hands.send({ image: video }),
  width: 640,
  height: 480
})
cam.start()

/* -------------------- ANIMATION LOOP -------------------- */

let lastPinch = false

function animate() {
  requestAnimationFrame(animate)

  particles.rotation.y += handX * 0.02
  particles.rotation.x += handY * 0.02

  material.size = 1.5 + handDistance * 10

  if (pinch && !lastPinch) {
    currentShape = (currentShape + 1) % Shapes.length
    generateShape(20 + handDistance * 80)
  }

  lastPinch = pinch

  renderer.render(scene, camera)
}

animate()

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(window.innerWidth, window.innerHeight)
})
</script>

</body>
</html>
