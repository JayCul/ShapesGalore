<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Universal AI Particle Engine</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 10; pointer-events: none; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        .badge { background: rgba(255,255,255,0.2); padding: 5px 12px; border-radius: 20px; font-size: 12px; backdrop-filter: blur(5px); }
        canvas { display: block; touch-action: none; }
        video { transform: scaleX(-1); position: fixed; bottom: 10px; right: 10px; width: 120px; height: auto; border-radius: 10px; border: 2px solid rgba(255,255,255,0.3); z-index: 5; }
    </style>
</head>
<body>

<div id="ui">
    <div class="badge" id="status">Waiting for Camera...</div>
    <h2 id="shape-name">Floating Stars</h2>
    <p id="hint">Show your palm to the camera</p>
</div>

<video id="webcam" playsinline muted autoplay></video>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

<script>
/**
 * 1. UNIVERSAL CAMERA ACCESS
 * Works on iOS, Android, and Desktop
 */
async function setupCamera() {
    const video = document.getElementById('webcam');
    const constraints = {
        video: {
            facingMode: "user", // Targets the front camera on phones
            width: { ideal: 640 },
            height: { ideal: 480 }
        }
    };

    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;
        return new Promise((resolve) => {
            video.onloadedmetadata = () => {
                video.play();
                resolve(video);
            };
        });
    } catch (e) {
        document.getElementById('status').innerText = "Camera Error: " + e.message;
        console.error(e);
    }
}

/**
 * 2. PARTICLE ENGINE (THREE.JS)
 */
let scene, camera, renderer, points, geometry;
const COUNT = 6000;

function initThree() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 4;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT * 3);
    for(let i=0; i<COUNT*3; i++) pos[i] = (Math.random()-0.5) * 10;
    
    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    
    const mat = new THREE.PointsMaterial({
        size: 0.035,
        color: 0x00ffff,
        transparent: true,
        blending: THREE.AdditiveBlending,
        opacity: 0.8
    });

    points = new THREE.Points(geometry, mat);
    scene.add(points);
}

/**
 * 3. SHAPE LIBRARY (The Templates)
 */
const Generators = {
    stars: () => {
        const p = [];
        for(let i=0; i<COUNT; i++) p.push((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10);
        return p;
    },
    tetrahedron: () => {
        const p = [];
        const size = 2;
        const vertices = [[1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1]];
        for(let i=0; i<COUNT; i++) {
            const v = vertices[i % 4];
            p.push(v[0] * size + (Math.random()-0.5), v[1] * size + (Math.random()-0.5), v[2] * size + (Math.random()-0.5));
        }
        return p;
    },
    flower: () => {
        const p = [];
        for(let i=0; i<COUNT; i++) {
            const t = (i / COUNT) * Math.PI * 20;
            const r = 2 * Math.sin(2.5 * t);
            p.push(r * Math.cos(t), r * Math.sin(t), (Math.random()-0.5)*0.2);
        }
        return p;
    }
};

function morph(shape) {
    const target = Generators[shape]();
    const current = geometry.attributes.position.array;
    document.getElementById('shape-name').innerText = shape.toUpperCase();

    gsap.to(current, {
        duration: 1.2,
        ease: "power2.inOut",
        ...target,
        onUpdate: () => { geometry.attributes.position.needsUpdate = true; }
    });
}

/**
 * 4. HAND TRACKING (MEDIAPIPE)
 */
const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
});

hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6 });

hands.onResults((results) => {
    if (results.multiHandLandmarks && results.multiHandLandmarks[0]) {
        document.getElementById('status').innerText = "Hand Active";
        const hand = results.multiHandLandmarks[0];
        
        // Dynamic Rotation based on hand position
        points.rotation.y = (hand[0].x - 0.5) * 4;
        points.rotation.x = (hand[0].y - 0.5) * 4;

        // Gesture: Detect Pinch
        const dist = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
        if(dist < 0.04) {
            morph('tetrahedron');
        } else if (dist > 0.15) {
            morph('flower');
        }
    } else {
        document.getElementById('status').innerText = "Looking for Hand...";
    }
});

// Start Everything
async function start() {
    initThree();
    const video = await setupCamera();
    
    // Create the detection loop
    const predict = async () => {
        await hands.send({ image: video });
        requestAnimationFrame(predict);
    };
    predict();

    function animate() {
        requestAnimationFrame(animate);
        points.rotation.z += 0.002;
        renderer.render(scene, camera);
    }
    animate();
}

start();

// Handle Resizing
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>

